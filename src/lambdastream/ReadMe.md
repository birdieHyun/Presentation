# 람다와 스트림 발표 

### 함수형 프로그래밍  
함수를 값으로 취급한다. 


## 목차 
1. 람다란? 
예전에 자바에서 함수 타입을 표현할 때, 추상 메서드를 하나만 당믕ㄴ 인터페이스를 사용했다.  
이런 인터페이스의 인스턴스를 함수객체 (function object) 라고 하여, 특정 함수나 동작을 나타내는데 사용했다. 
```java
public class MyLambda {

    public static void main(String[] args) {

        List<String> list = new ArrayList<>();
        list.add("1000");
        list.add("100");
        list.add("10");
        list.add("1");

        // list 를 문자열 길이순으로 정렬하고 싶다면?
        Collections.sort(list, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.length() - o2.length();
            }
        });

        for (String s : list) {
            System.out.println(s); // 1, 10, 100, 1000 순으로 정렬된다.
        }
    }

} 
```
자바 8 이전, 함수 객체를 사용하는 과거 객체지향 디자인 패턴에는 익명 클래스면 충분했다.  
이 코드에서는 Comparator 인터페이스가 정렬을 담당한다.  
이 익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.  
  
자바 8에 와서 추상 메서드 하나짜리 인터페이스는 특별한 의미를 인정받아 특별한 대우를 받고 **람다식**이 탄생했다.  

위 코드를 람다식으로 바꾸면  
  
```java
public class Lambda {
    public static void main(String[] args) {
        Collections.sort(list,
                (s1, s2) -> Integer.compare(s1.length(), s2.length));
    }
}
```  
여기서 람다의 타입은 Comparator<String>  
매개변수 s1, s2 의 타입은 String,  
반환값의 타입은 int 이지만  
코드에서 언급이 없다.  
우리 대신 컴파일러가 문맥을 읽고 타입을 추론해주었다. 
**타입을 명시해야 코드가 더 명확할 때만 제외하고, 람다의 모든 매개변수 타입은 생략하자**  
> 람다의 타입은 제네릭을 통해 추론할 수 있다. 즉 컴파일러는 제네릭을 통해 타입을 추론한다.  
  
주의점 : 람다는 이름도 없고 문서화도 못하기 때문에, 코드 자체로 동작히 명확히 설명되지 않거나, 코드 줄 수가 많아지면 람다를 사용하면 안된다.  
(추가 공부할 점 : 지금까지 본 람다는 대부분 한줄로 해결되었다. 여러줄 되는 람다? 공부해서 다시 내용 추가하자)  


2. 메서드참조? 
람다 자리에 비교자 생성 메서드를 사용하면 코드가 더 간결해진다. 
```java
public class Lambda {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            list.add("0");
        }
        
        // 자바 8때 List 인터페이스에 추가된 sort 메서드를 활용하면 더 짧아진다. 
        Collections.sort(list, Comparator.comparingInt(String::length));

        list.sort(comparingInt(String::length));
    }
}
```
> 메서드 참조도 함수형 프로그래밍의 일부이다. 또한 람다보다 가독성이 더 좋다는 장점을 가지고 있다.  
  
람다로 구현했을 때 코드가 너무 길거나 복잡하면 메서드 참조가 좋은 대안이 되어준다.  
IDE 에서 주로 메서드 참조를 추천해주는데,  
**메서드 참조가 짧다면 메서드 참조를 사용하고, 그렇지 않으면 람다를 사용한다.**   
**무조건적으로 짧은 것이 아닌 가독성이 좋은 것을 선택한다.**  

람다는 간단한 계산이 필요할 때 사용하도록 하고,  
메서드참조는 메서드 명이 있기 때문에 가독성에 도움을 줄 수 있다.



3. 스트림    
스트림의 기본적인 특징 
- 스트림은 데이터 소스를 변경하지 않는다. 
  - 스트림은 데이터 소스로부터 데이터를 읽기만 할 뿐 데이터 소스를 변경하지 않는다. -> 필요하다면 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수 있다.  
  ```java
List<String> sortedList = strStream.sorted().collect(Collectors.toList());
```
스트림의 결과를 새로운 List 에 담아서 반환한다.   

- 스트림은 일회용이다. 
    - 스트림의 최종 연산이 종료되고 나면, 닫혀서 다시 사용할 수 없다.  
    - 필요하다면 스트림을 다시 생성해야 한다. 



 

4. 버디 수준에서 어떻게 활용할 수 있을까?
  
  
### 함수형 프로그래밍   
함수형 프로그래밍이란 함수나 메서드가 수학의 함수처럼 동작함을, 즉 부작용 없이 동작함을 의미한다.    
즉, 함수를 마치 일반값처럼 사용해서 인수로 전달하거나, 결과로 반환받거나, 자료구조에 저장할 수 있음을 의미한다.  
일반값처럼 취급할 수 있는 함수를 **일급 함수**라고 한다.  
자바 8이 이전 버전과 구별되는 특징 중 하나가 일급함수를 지원한다는 점이다.   

#### 고차원 함수  
- 고차원 함수
  - 하나 이상의 함수를 인수로 받음 
  - 함수를 결과로 반환 

스트림 연산으로 전달하는 함수는 부작용이 없어야 하며, 부작용을 포함하는 함수를 사용하면 문제가 발생한다는 사실을 설명했다.  
(부작용을 포함하는 함수를 사용하면 문제가 발생한다.) 
  
- 함수를 묘듈화하고 코드를 재사용하는데 도움을 주는 기법인 **커링**을 알아보자   
**커링**은 x 와 y 라는 두 인수를 받는 함수 f 를 한 개의 인수를 받는 g 라는 함수로 대체하는 기법이다. 이때 g 라는 함수 역시 하나의 인수를 받는 함수를 반환한다.   
- 함수 g 와 원래함수 f 가 최정족으로 반환하는 값은 같다.   
즉 f(x, y) = (g(x))(y) 가 성립한다.  
